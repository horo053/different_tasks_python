#2. Объявите анонимную (лямбда) функцию с одним параметром для возведения числа в квадрат.
# Присвойте эту функцию переменной get_sq. Вызывать функцию не нужно, только объявить.
get_sq = lambda q: q ** 2


#3. Объявите анонимную (лямбда) функцию с двумя параметрами для деления первого целого числа (первого параметра)
# на второй (второй параметр). Если происходит деление на ноль, то функция должна возвращать значение None,
# иначе - результат деления. Присвойте эту функцию переменной get_div. Вызывать функцию не нужно, только задать.
get_div = lambda x, y: None if y == 0 else x/y


#4. Объявите анонимную (лямбда) функцию для вычисления модуля числа (то есть, отрицательные числа нужно
# делать положительными). Вызовите эту функцию для числа x, которое следует прочитать из входного потока командой:
# x = float(input()). Отобразите результат работы функции на экране.
x = float(input())
mod = lambda x:abs(x)
print(mod(x))


#5. Объявите анонимную (лямбда) функцию для определения вхождения в переданную ей строку фрагмента "ra". То есть,
# функция должна возвращать True, если такой фрагмент присутствует в строке и False в противном случае.
# Вызовите эту функцию для строки s, которую следует прочитать из входного потока командой:
# s = input(). Отобразите результат работы функции на экране.
s = input()
ra_in_str = lambda s: True if 'ra' in s else False
print(ra_in_str(s))


#6. В программе задана функция filter_lst (см. программу ниже), которая отбирает элементы, переданного
# ей итерируемого объекта и возвращает сформированный кортеж значений. На вход программы поступает список целых чисел,
# записанных через пробел. Необходимо прочитать эти числа и сохранить в списке digs.
# Затем, вызовите функцию filter_lst несколько раз для формирования:
# кортежа из всех значений списка digs (передается в параметр it);
# кортежа только из отрицательных чисел переданного списка digs;
# кортежа только из неотрицательных чисел (то есть, включая и 0) переданного списка digs;
# кортежа из чисел в диапазоне [3; 5] переданного списка digs.
# Для отбора нужных значений формальному параметру key следует передавать соответствующие определения анонимной функции.
# Каждый результат работы функции следует отображать с новой строки командой: print(*lst)
# где lst - кортеж, возвращенный функцией filter_lst.
def filter_lst(it, key=None):
    if key is None:
        return tuple(it)

    res = ()
    for x in it:
        if key(x):
            res += (x,)

    return res

digs = [int(i) for i in input().split()]
lst = filter_lst(digs)
print(*lst)
lst = filter_lst(digs, lambda i: i < 0)
print(*lst)
lst = filter_lst(digs, lambda i: i >= 0)
print(*lst)
lst = filter_lst(digs, lambda i: i in range(3,6))
print(*lst)
