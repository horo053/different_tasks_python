from datetime import date, time, datetime, timedelta

#1. Во время решения очередной задачи программист фиксирует время начала и окончания ее решения и добавляет
# полученные результаты в список data. Каждый результат представляет собой кортеж, первым элементом которого
# является время начала решения в виде строки в формате HH:MM, вторым элементом — время окончания решения в
# виде строки в том же формате. Дополните приведенный ниже код, чтобы он вывел общее целое количество минут,
# которое программист затратил на решение всех задач.
data = [('07:14', '08:46'),
        ('09:01', '09:37'),
        ('10:00', '11:43'),
        ('12:13', '13:49'),
        ('15:00', '15:19'),
        ('15:58', '17:24'),
        ('17:57', '19:21'),
        ('19:30', '19:59')]

s = timedelta(hours=0,minutes=0)
for i in data:
    print(i)
    start = i[0]
    end = i[1]
    s += datetime.strptime(end, '%H:%M') - datetime.strptime(start, '%H:%M')
k = int(s.total_seconds() // 60)
print(k)


#2. Число 13 считалось дьявольским издавна. Это имеет свое объяснение, и не одно: тут есть трактовки,
# связанные с Тайной вечерей — где были Христос и 12 апостолов, один из которых стал предателем.
# Есть поверье, что для шабаша нужны 12 ведьм и сатана. В истории число 13 в связке с пятницей стало
# «несчастливым» в 1307 году, когда король Франции Филипп Красивый отдал приказ схватить всех
# тамплиеров — членов рыцарского ордена крестоносцев. Все они были сожжены на кострах инквизиции,
# и произошло это в пятницу, 13 апреля. Докажите, что 13-е число месяца чаще всего приходится на пятницу.
# Напишите программу, которая вычисляет, сколько тринадцатых чисел приходится на каждый день недели
# в период с 01.01.0001 по 31.12.9999.
days_13 = [0,0,0,0,0,0,0]
for year in range(1, 10000):
    for month in range(1,13):
        days_13[date(year, month, 13).weekday()] += 1

print(*days_13, sep='\n')


#3. Дан режим работы магазина:
# Понедельник	9:00 - 21:00
# Вторник	9:00 - 21:00
# Среда	9:00 - 21:00
# Четверг	9:00 - 21:00
# Пятница	9:00 - 21:00
# Суббота	10:00 - 18:00
# Воскресенье	10:00 - 18:00
# Напишите программу, которая принимает на вход текущие дату и время и
# определяет количество минут, оставшееся до закрытия магазина.
weekday = (timedelta(hours=8, minutes=59), timedelta(hours=21))
weekend = (timedelta(hours=8, minutes=59), timedelta(hours=18))
worktime = {0: weekday, 1: weekday,
            2: weekday, 3: weekday,
            4: weekday, 5: weekend,
            6: weekend}
data = datetime.strptime(input(), '%d.%m.%Y %H:%M')
da = date(data.year, data.month, data.day)
ti = timedelta(hours=data.hour, minutes=data.minute)
mi = timedelta(hours=0,minutes=0)
for k, v in worktime.items():
    if da.weekday() == k:
        if v[0].total_seconds() < ti.total_seconds() < v[1].total_seconds():
            mi = v[1] - ti
            print(int(mi.total_seconds()/60))
        else:
            print('Магазин не работает')


#4. Даны две даты — левая и правая границы диапазона соответственно. Напишите программу, которая из этого диапазона,
# включая границы, выводит, начиная с даты, у которой сумма дня и месяца нечетная, каждую третью дату,
# только если она не понедельник и не четверг. --
start = datetime.strptime(input(), '%d.%m.%Y')
start = date(start.year, start.month, start.day)
end = datetime.strptime(input(), '%d.%m.%Y')
end = date(end.year, end.month, end.day)
lst = [date.fromordinal(i) for i in range(start.toordinal(), end.toordinal()+1)]
lst2 = []
for i in lst:
    if (i.day + i.month % 2) != 0 and (i.weekday() not in [0,3]):
        lst2.append(i)
for i in range(len(lst2)):
    if i == 0 or i%2==0:
        print(lst2[i])
